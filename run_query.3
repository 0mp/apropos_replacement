.\" $NetBSD$
.\"
.\" Copyright (c) 2011 Abhinav Upadhyay <er.abhinav.upadhyay@gmail.com>
.\" All rights reserved.
.\"
.\" This code was developed as part of Google's Summer of Code 2011 program.
.\" Thanks to Google for sponsoring.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in
.\"    the documentation and/or other materials provided with the
.\"    distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
.\" ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
.\" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
.\" FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE
.\" COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
.\" INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING,
.\" BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
.\" LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
.\" AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
.\" OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
.\" OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.Dd August 17, 2011
.Dt RUN_QUERY 3
.Os
.Sh NAME
.Nm run_query
.Nd Run a query against
.Pa /var/db/man.db
and process the results in a callback function.
.Sh SYNOPSIS
.In apropos-utils.h
.Ft int
.Fn run_query "sqlite3 *db" "const char **snippet_args" "query_args *args"
.Sh DESCRIPTION
The
.Fn run_query
function prepares the user supplied query in a form suitable to be run
against
.Pa /var/db/man.db
and executes the query.
For each row obtained in the result set
.Fn run_query
will call the user supplied callback function, which should contain the
logic for processing the data thus obtained.
.Pp
The
.Fn run_query
function takes following arguments:
.Pp
.Fa sqlite3 *db Ta Handle to the database connection which can be
obtained by calling
.Fn init_db
.Pp
.Fa const char *snippet_args
An array of strings which specify the
delimiters to the matching text in snippet.
It is an optional argument and caller can supply a
.Dv NULL
value for
it, in which case, a default value of
.Brq \&"\&", \&"\&", \&"...\&"
will be used.
The 3 members of array specify following values:
.Bl -enum -offset indent
.It
The first element marks the beginning of each matching token in the snippet.
.It
The second element the end of each matching token in the snippet.
.It
The third element is used to delimit the beginning and end of the snippet.
.El
For example for highlighting matching tokens in HTML style mark-up use this
value:
.Bd -literal -offset indent
 const char **snippet_args = {
	"<b>",
	"</b>",
	"..."
 };
.Ed
.Pp
.Fa query_args *args
query_args is a struct
which is defined in apropos-utils.h.
It has following fields:
.Bl -column -offset indent "Struct Field" "Field Description"
.It Li const char *search_str Ta This is the query as entered by the user.
You may want to pre-process it to do sanitization etc.
.It Li const char **sec_nums Ta \&It is an array of char * wherein each index element represents the
section number in which search should be performed.
The sections whose corresponding index element in this array is set to
.Dv NULL
are not searched in.
If all the elements in the array are
.Dv NULL
then all the sections are searched.
.It Li const char *nrec Ta \&It specifies the number of matching rows to fetch from the database.
.It Li int (*callback) (void *, int, char **, char **) Ta
.Pp
This is the callback function which will
be called for each row retrieved from the database.
The function should return a value of 0 on successful execution.
A non-zero return value will indicate a failure and run_query will return.
The interface of the callback function is described later in this section.
.It Li void *callback_data Ta \&Use this argument to pass any data to the callback function.
It can be retrieved inside the callback function from it's first argument.
.It Li char **errmsg Ta If an error occurs while fetching the data from the database,
a human readable error message will be stored in errmsg.
If no error occurs then errmsg will be set to
.Dv NULL .
In case errmsg is not
.Dv NULL ,
then the caller should make sure to free it.
.El
.Pp
The interface of the callback function is as follows:
.Pp
.Fn int callback "void *callback_data" "int ncol" "char **col_values" "char **col_names"
.Bl -column -offset indent "Function" "Argument Description"
.It Li void *callback_data Ta This is the caller supplied data.
.It Li int ncol Ta Ta \&It represents the number of columns in the result set.
.It Li char **col_values Ta This is an array of strings, where each index element
represents the value of the correspondigly indexed column in the result set.
.It Li char **col_names Ta This array stores the name of the columns whose values
have been fetched from the database.
.El
The query which
.Fn run_query
results in a 5 column result set.
Those are as follows:
.Bl -column -offset indent "Column Name" "Column Description"
.It Li section Ta The section number of the page.
.It Li name Ta The name of the page.
.It Li snippet Ta The snippet of the matching text in the page.
.It Li name_desc Ta The one line description from NAME section.
.It Li rank Ta A double value indicating rank/weight of the page.
.El
.Sh RETURN VALUES
On successful execution the
.Fn run_query
function will return 0 and in case of an error \-1 will be returned.
.Sh FILES
.Bl -hang -width /var/db/man.db -compact
.It Pa /var/db/man.db
The Sqlite FTS database which maintains an index of the manual pages.
.Sh EXAMPLES
Following is a code excerpt of how apropos.c uses run_query.
.Bd -literal -offset indent
#include <apropos-utils.h>
query_args args;
char *errmsg = NULL;
const char **sec_nums = {NULL, "2", "3", NULL, NULL, NULL, NULL, NULL, NULL};
args.search_str = argv[1];
args.sec_nums = sec_nums;
args.nrec = "10";
args.callback = &query_callback;
args.callback_data = NULL;
args.errmsg = &errmsg;
if (run_query(db, NULL, &args) < 0)
		errx(EXIT_FAILURE, "%s", errmsg);
}

free(query);
free(errmsg);

static int
query_callback(void *data, int ncol, char **col_values, char **col_names)
{
	char *section = col_values[0];
	char *name = col_values[1];
	char *snippet = col_values[2];
	char *name_desc = col_values[3];
	/* The user supplied data could be obtained as follows */
//	 my_data *buf = (my_data *) data;

	fprintf(stdout, "%s(%s)\t%s\n%s\n\n", name, section, name_desc,
	snippet);
	return 0;
}
.Ed
.Sh SEE ALSO
.Xr apropos-utils 3 ,
.Xr close_db 3 ,
.Xr init_db 3 ,
.Xr run_query_html 3 ,
.Xr run_query_pager 3
.Sh AUTHORS
.An Abhinav Upadhyay
